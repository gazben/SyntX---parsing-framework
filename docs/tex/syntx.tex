% The MIT License (MIT)
% 
% Copyright (c) 2013, Gergely Nagy
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in
% all copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
% THE SOFTWARE.
\documentclass[12pt]{article}
\usepackage[paper=a4paper, margin=2.5cm]{geometry}
\usepackage{fancyhdr}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{setspace}
\usepackage[T1]{fontenc}
\usepackage[lighttt]{lmodern}	%needed to have bold teletype (to have bold keywords in lstlisting)
\usepackage{hfoldsty}			%has to go after \usepackage{lmodern} to take effect
\usepackage{listings}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancyhf[FL]{\scriptsize{\textit{The SyntX Parser Library}}}
\fancyhf[FC]{\scriptsize{\textit{\textbf{\thepage}}}}
\fancyhf[FR]{\scriptsize{\textit{\today}}}

%\lstset{basicstyle=\scriptsize\ttfamily, keywordstyle=\bfseries\ttfamily}
\lstset{basicstyle=\scriptsize\ttfamily, stringstyle=\itshape\ttfamily,
keywordstyle=\bfseries\ttfamily,aboveskip=10pt,
belowskip=10pt, tabsize=2, xleftmargin=5pt, captionpos=b, 
literate={á}{{\'a}}1 {é}{{\'e}}1 {ó}{{\'o}}1 {ö}{{\"o}}1 {ú}{{\'u}}1 {ü}{{\"u}}1}

\begin{document}
\sloppy

\vspace*{2em}
\centerline{\Huge\textbf{The SyntX Parser Library}}
\vspace{5em}

\begin{center}
	\begin{minipage}[h]{0.85\linewidth}
		\itshape
		The SyntX parser library is a set of C++ classes that enables users to create a parser for an
		LL(k) grammar by giving the production rules with an EBNF-like notation as C++ expressions. There is
		thus no need for a precompiler, the parser can be an integral part of a C++ project.
	\end{minipage}
\end{center}

\vspace{4.5em}

\section*{Recursive descent parsing}
The SyntX library is based upon the theory of recursive descent parsers (RDPs). In order to gain a deep and confident
understanding of the library, one has to be familiar with the rudiments of recursive descent parsing.

This section provides a brief introduction with a very simple example. It also introduces some of the types
and notations that are used in the source code of the library as well.

\subsection*{The Extended Backus-Naur Form}
EBNF\footnote{Extended Backus-Naur Form --
\href{http://en.wikipedia.org/wiki/Ebnf}{en.wikipedia.org/wiki/Ebnf}} is a widespread notation that can be
used to express context-free grammars. It is the extension of the Backus-Naur Form (BNF) and actually several
EBNF styles exist. This document uses the one defined by W3C\footnote{World Wide Web Consortium --
\href{http://www.w3.org}{www.w3.org}}.

The "Hello World" grammar that is used to introduce parsing describes a mathemtical expression containg
numbers, the four basic operations and an arbitrary depth of parentheses. The grammar below is even simpler
than that, it allows only addition, so the way precedence can be handled is not shown. It allows an infinite
depth of grouping using parentheses however. The ease with which recursive structures can be handled by
EBNF grammars and RDPs is a very important feature and is often exploited.

\begin{center}
	\begin{minipage}[h]{0.5\textwidth}
		\begin{lstlisting}[breaklines=true]
addition = addend ('+' addend)*
addend = [0-9] | expression
expression = '(' addition ')'
		\end{lstlisting}
	\end{minipage}
\end{center}

The production rule named \texttt{addition} is the \emph{start rule}. The text that we're trying to analyse
should conform to this rule as a whole. The details can be investigated by following the references to other
rules.

The \texttt{addition} rule states that an addition is made up of an addend that can be followed by an
arbitrary number of addends each preceded by a '+' operator. The \texttt{*} operator in EBNF allows an zero or
more occurence of a rule (or a sequence of rules). This means that an addition may consist of a single addend
as well, which is OK: a number can be thought of as a mathematical expression.

If we wanted to have at least two addends seperated by a '+' operator, than EBNF's \texttt{+} should be used,
which allows one or more occurences.

An addend in our simple grammar can be either a single digit (given here by a the shorthand used to describe
character sequences in EBNF) or an expression. The \texttt{|} operator stands for \emph{alternation}.

The interesting part lays in the \texttt{expression} rule. An expression is an addition enclosed by
parantheses. This is how the grammar becomes recursive and how an expression of infinite complexity can be
described by a handful of production rules.

Let's see some examples! The simplest possible expression is a single digit:

\begin{center}
	\begin{minipage}[h]{0.1\textwidth}
		\begin{lstlisting}[breaklines=true]
8
		\end{lstlisting}
	\end{minipage}
\end{center}

The start rule is where the matching starts, so we assume that the our text is an \texttt{addition}. An addition starts
with an \texttt{addend}. An \texttt{addend} can be a digit, so indeed the text starts with an addend. Thus the
first part of the \texttt{addition} rule matched, we may move on to the rest of the text. Next we're looking
for a '+' character which we don't find. Luckiliy this part of the rule is optional, so we get to the end of
the rule having matched the entire text. This is a successful match.

Let's go for something a bit more complex next:

\begin{center}
	\begin{minipage}[h]{0.2\textwidth}
		\begin{lstlisting}[breaklines=true]
2 + 3 + (4 + 8)
		\end{lstlisting}
	\end{minipage}
\end{center}

The \texttt{addition} rule will find two digits with a '+' character in between. It could already stop there
as we have a sum which complies to the rules, but we haven't reached the end of the text and actually the
rule allows more than two addends. So the parsing continues, we find a second '+' character and then an
opening parenthesis. This is OK, as the \texttt{addend} rule doesn't only match digits, \texttt{expression}s
are also allowed.

So next we're trying to match the \texttt{expression} rule which contains an \texttt{addition} between
parentheses. That's exactly what we have here so, again, we have a successful match. Please note that the
\texttt{addition} inside the \texttt{expression} can again turn into an \texttt{expression} and then into an
\texttt{addition} -- this is exactly how the arbitrary depth of the expression is analysed.

\subsection*{Functions corresponding to each production rule}
In a recursive descent parser there is a function corresponding to every production rule. These functions
receive the context of parsing (i.e. the text to be parsed and the current position) and return a Boolean
value which is true if the function could match a certain substring of the text and could move the position
further towards the end of the text. If the function returns false, the position is not altered.

Following is an example function that matches one character of the text if it can be found in the string
serving as a character set taken as an argument. The structure of this function is characteristic of the
rule methods in the SyntX library.

\begin{center}
	\begin{minipage}[h]{0.8\textwidth}
		\begin{lstlisting}[language=C++, breaklines=true, numbers=left]
bool character(match_range &context, std::string const &characters) {
  match_range local = context;

  if (local.first == local.second) return false;

  for (auto c: characters) {
    if (*local.first == c) {
      ++local.first;
      context.first = local.first;
      return true;
    }
  }

  return false;
}
		\end{lstlisting}
	\end{minipage}
\end{center}

The \texttt{match\_range} type is an \texttt{std::pair} that holds two \texttt{std::string::iterator}s. It
describes the context of the parsing: the first element points to the current position (the character that
should be analysed next), the second to the end of the text.

\begin{center}
	\begin{minipage}[h]{0.8\textwidth}
		\begin{lstlisting}[language=C++, breaklines=true]
using match_range = std::pair< std::string::iterator,
                               std::string::iterator >;
		\end{lstlisting}
	\end{minipage}
\end{center}

The function has two arguments, the context and the character set that enumerates the characters that are
accepted. The context is taken as a non-constant reference because the function sets the current position
after the the last character it could match.

In line~2 a copy of the context is created. This copy will reflect the analysis performed by the function. A
complex parser function can delve deep into a string before finding out that it doesn't match it after all. It
might also call a series of other parsing functions on the way that also alter this value, so it is absolutely
necessary to keep a copy of the original position and only change that value when there is a successful match.

Every parser function that operates at the character level should constantly check if the end of the text has
been reached. This can be seen in line~4.

As long as a function finds characters it can consume, it advances the current position, i.e. the first
element in the local copy of the context (line~8).

If a function matches a certain substring of the text and can not advance further, two things need to be done:
the context taken by reference has to be changed to reflect the advancement in the analysis of the text and it
has to return true (lines~9-10). Otherwise it has to merely return false (line~14), the context is left
unchanged.

%\vfill
%\begin{center}
%\footnote\emph{Please consider the environment before printing this document.}
%\end{center}
%\vfill
\end{document}
